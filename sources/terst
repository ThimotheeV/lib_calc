# Nombre de marqueur par deme, freq d'un des deux allèles par deme.
FST_WC < -function(DATA_SIZE, DATA_FREQ)
{
  Nrace = dim(DATA_SIZE)[2];  
  SumNi = rowSums(DATA_SIZE)

  Nic = DATA_SIZE-(DATA_SIZE**2)/SumNi; 
  Nc = rowSums(Nic)/(Nrace-1)

  MSG = (rowSums(DATA_FREQ*(1-DATA_FREQ)*DATA_SIZE)) / (SumNi-1)
  PA = rowSums(DATA_FREQ*DATA_SIZE)/SumNi
  MSP = (rowSums(DATA_SIZE*((DATA_FREQ-PA)**2)))/(Nrace-1)

  NUMERATOR = (MSP-MSG); 
  DENOMINATOR = (MSP+(Nc-1)*MSG)

  FST = NUMERATOR/DENOMINATOR; FST[FST < 0] = 0  # mise � zero des FST negatifs
  FSTmoy = mean(FST, na.rm=T); FSTmoy_corr = mean(NUMERATOR)/mean(DENOMINATOR)

  list(FST=FST, FSTmoy=FSTmoy, FSTmoy_corr=FSTmoy_corr,
       num=NUMERATOR, den=DENOMINATOR)
}


fstats < -function(demedet.obj, niter=0, c.int=0.95, n.snp.jack=1000){
# p176-p179 Weir 1996
  mat.nhets = demedet.obj$demedet[[demedet.obj$deme.list[1]]][, 1]
  mat.nhom1 = demedet.obj$demedet[[demedet.obj$deme.list[1]]][, 2]
  mat.nhom2 = demedet.obj$demedet[[demedet.obj$deme.list[1]]][, 3]
  n.deme = length(demedet.obj$deme.list)
  for(i in 2: n.deme){
mat.nhets = cbind(mat.nhets, demedet.obj$demedet[[demedet.obj$deme.list[i]]][, 1])
mat.nhom1 = cbind(mat.nhom1, demedet.obj$demedet[[demedet.obj$deme.list[i]]][, 2])
mat.nhom2 = cbind(mat.nhom2, demedet.obj$demedet[[demedet.obj$deme.list[i]]][, 3])
  }
  mat.ntot = mat.nhets+mat.nhom1+mat.nhom2
  ntot.all.demes = rowSums(mat.ntot)
  p_a_i = (mat.nhom1 + 0.5*mat.nhets)/mat.ntot
  p_a_bar = (rowSums(mat.nhom1) + 0.5*rowSums(mat.nhets)) / ntot.all.demes
  s2a = (p_a_i - matrirep(p_a_bar, n.deme), length(p_a_bar), n.deme))**2  # (apply(p_a_i,1,"-",p_a_bar))**2
  p_aa_i = mat.nhom1/mat.ntot
#  Ha       =  2*rowSums(mat.ntot*(p_a_i-p_aa_i))/ntot.all.demes
  nc = (ntot.all.demes - rowSums(mat.ntot**2)/ntot.all.demes)/(n.deme-1)

# cf Table 5.4 : MS. = SS. / df (colonne 3/colonne2)
  MSP = 2*rowSums(mat.ntot*s2a) / (n.deme-1)
  MSI = rowSums(mat.ntot*(p_a_i+p_aa_i-2*(p_a_i**2))) / (ntot.all.demes - n.deme)
  MSG = rowSums(mat.ntot*(p_a_i-p_aa_i)) / ntot.all.demes

  S1 = (MSP-MSI);  S2 = (MSP + (nc-1)*MSI + nc*MSG); S3 = 2*nc*MSG
  Fhat = 1 - S3/S2;  Theta = S1/S2;  fhat = (S2-S3-S1)/(S2-S1)

  mean.S1 = mean(S1, na.rm=T);  mean.S2 = mean(S2, na.rm=T);  mean.S3 = mean(S3, na.rm=T)
  Fhatmoy = 1 - mean.S3/mean.S2
  Thetamoy = mean.S1/mean.S2
  fhatmoy = (mean.S2 - mean.S3 - mean.S1)/(mean.S2 - mean.S1)
# inbreeding coefficient par deme: p.80 Weir, 96
  p_Aa_i = mat.nhets/mat.ntot
  fdeme.num = (mat.ntot-1)*p_Aa_i
  fdeme.den = 2*mat.ntot*p_a_i*(1-p_a_i) - 0.5*p_Aa_i

  # equivaut au Fis locus specifique calcule dans .DIV de Genedeme
  fdeme = 1 - rowSums(fdeme.num, na.rm=TRUE)/rowSums(fdeme.den, na.rm=TRUE)
  fdeme.moy = 1-colMeans(fdeme.num, na.rm=T)/colMeans(fdeme.den, na.rm=T)
  names(fdeme.moy) = demedet.obj$deme.list

  if(niter > 0){
   tmp.index = 1: length(S1)
   cat("Computing confidence interval via jacknife\n")
   value.store = matri0, niter, length(fdeme.moy)+3)
   for(i in 1: niter){
    if(i % %500 == 0){cat("Iteration: ", i, "\n")}
    tmp.snp = sample(tmp.index, n.snp.jack, replace=FALSE)
    iter.mean.S1 = mean(S1[tmp.snp], na.rm=T);  iter.mean.S2 = mean(S2[tmp.snp], na.rm=T);  iter.mean.S3 = mean(S3[tmp.snp], na.rm=T)
value.store[i, ] = c(1-colMeans(fdeme.num[tmp.snp, ], na.rm=T)/colMeans(fdeme.den[tmp.snp, ], na.rm=T),
                   1 - iter.mean.S3/iter.mean.S2, iter.mean.S1 /
                       iter.mean.S2, (iter.mean.S2-iter.mean.S3 -
                                      iter.mean.S1)/(iter.mean.S2-iter.mean.S1)
    )
   }
CI = apply(value.store, 2, quantile, probs=c((1-c.int)/2, (c.int+1)/2))
   f.deme.ci = CI[, 1:n.deme]
   colnames(f.deme.ci) = demedet.obj$deme.list
   fstats.ci = CI[, -(1:n.deme)]
   colnames(fstats.ci) = c("F", "Theta", "f")
  }else{
   fstats.ci=NA ; f.deme.ci=NA
  }

  fstats=c(Fhatmoy,Thetamoy,fhatmoy) ; names(fstats)=c("F","Theta","f")

list(ThetaBySNP=Theta,Fhat_by_SNP=Fhat,fhat_by_SNP=fhat,fis_by_SNP=fdeme,fis.deme=fdeme.moy,fstats=fstats,fis.deme.ci=f.deme.ci,fstats.ci=fstats.ci)
}
